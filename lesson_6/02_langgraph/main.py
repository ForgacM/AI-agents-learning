from dotenv import load_dotenv, find_dotenv
from langgraph.graph import START, END
from langgraph.graph import StateGraph

from .graph import (
    MyState,
    ExtractCitiesNode,
    CheckCacheNode,
    FetchWeatherNode,
    StoreCacheNode,
    CompileResultsNode,
    needs_fetch_router,
)
from .visualizer import visualize

_ = load_dotenv(find_dotenv())  # read local .env file


async def main():

    # ---------------------------
    # Define the graph
    # ---------------------------
    workflow = StateGraph(MyState)

    # Add nodes
    workflow.add_node("extract_cities", ExtractCitiesNode)
    workflow.add_node("check_cache", CheckCacheNode)
    workflow.add_node("fetch_weather", FetchWeatherNode)
    workflow.add_node("store_cache", StoreCacheNode)
    workflow.add_node("compile_results", CompileResultsNode)

    # Add edges
    workflow.add_edge(START, "extract_cities")
    workflow.add_edge("extract_cities", "check_cache")

    # Conditional edge: after checking cache, decide if we need to fetch
    workflow.add_conditional_edges(
        "check_cache",
        needs_fetch_router,
        {
            "fetch_weather": "fetch_weather",
            "compile_results": "compile_results",
        },
    )

    # After fetching weather, store in cache
    workflow.add_edge("fetch_weather", "store_cache")

    # After storing, compile results
    workflow.add_edge("store_cache", "compile_results")

    # End after compiling
    workflow.add_edge("compile_results", END)

    # Compile graph
    graph = workflow.compile()

    visualize(graph, "graph.png")
    # ---------------------------
    # Run the graph
    # ---------------------------

    conversation = {
        "messages": [
            {
                "role": "user",
                "content": (
                    "Give me tomorrow weather for New York. Use DB cache if not exist city in cache than call weather api. Return me formated output"
                ),
            },
            {
                "role": "system",
                "content": (
                    """
                    You are a workflow agent responsible for providing weather information for any cities requested by the user, including a single city or multiple cities.
You MUST use only the tools/agents provided to you. Do NOT invent or call any unlisted tools.
Task
For each city mentioned in the user message:
Identify the city names using the extract_cities agent.
For each extracted city:
Call check_cache to see if valid weather data already exists.
If cached data exists, use it.
If cached data does NOT exist or is expired, call fetch_weather to retrieve fresh weather data.
After fetching, call store_cache to save the data into the cache.
Once all cities are processed, call compile_results to produce the final output.
Allowed Agents (ONLY these)
extract_cities → Extracts all city names mentioned in the user message.
check_cache → Checks if weather data is stored for a city.
fetch_weather → Fetches current weather from the weather API.
store_cache → Saves weather data to the DB cache.
compile_results → Assembles all weather data into a structured final answer.
Output Requirements
Final output must always be generated by compile_results.
Output should be human-readable, formatted, and contain for each city:
Name of the city
Current temperature
Current weather description
Date of the weather data
Cities may be 1 or many, depending on the user message.
Rules
NEVER generate weather data yourself — always rely on cache or API.
NEVER call tools outside the allowed list.
ALWAYS follow the sequence:
extract → cache-check → (fetch → store) → compile
If the user mentions only one city, process that single city normally.
If the user mentions multiple cities, process each independently.
If no city can be extracted, return a helpful error via compile_results.
Your job is to decide which agent to call at each step and provide correct parameters."""
                )
            }
        ],
        "cities": [],
        "weather_date": "",
        "cached_cities": [],
        "missing_cities": [],
        "needs_fetch": False,
    }

    result = await graph.ainvoke(conversation)
    # Get the last message which contains the JSON output
    final_message = result["messages"][-1]
    if isinstance(final_message, dict):
        print(final_message.get("content", ""))
    elif hasattr(final_message, "content"):
        print(final_message.content)
    else:
        print(final_message)


if __name__ == "__main__":
    import asyncio

    asyncio.run(main())